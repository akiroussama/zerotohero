{
  "sourceFile": "mockServiceWorker.js",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1669638745986,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1669638745986,
      "name": "Commit-0",
      "content": "/* eslint-disable */\r\n/* tslint:disable */\r\n\r\n/**\r\n * Mock Service Worker (0.44.2).\r\n * @see https://github.com/mswjs/msw\r\n * - Please do NOT modify this file.\r\n * - Please do NOT serve this file on production.\r\n */\r\n\r\nconst INTEGRITY_CHECKSUM = 'b3066ef78c2f9090b4ce87e874965995'\r\nconst activeClientIds = new Set()\r\n\r\nself.addEventListener('install', function () {\r\n    self.skipWaiting()\r\n})\r\n\r\nself.addEventListener('activate', function (event) {\r\n    event.waitUntil(self.clients.claim())\r\n})\r\n\r\nself.addEventListener('message', async function (event) {\r\n    const clientId = event.source.id\r\n\r\n    if (!clientId || !self.clients) {\r\n        return\r\n    }\r\n\r\n    const client = await self.clients.get(clientId)\r\n\r\n    if (!client) {\r\n        return\r\n    }\r\n\r\n    const allClients = await self.clients.matchAll({\r\n        type: 'window',\r\n    })\r\n\r\n    switch (event.data) {\r\n        case 'KEEPALIVE_REQUEST': {\r\n            sendToClient(client, {\r\n                type: 'KEEPALIVE_RESPONSE',\r\n            })\r\n            break\r\n        }\r\n\r\n        case 'INTEGRITY_CHECK_REQUEST': {\r\n            sendToClient(client, {\r\n                type: 'INTEGRITY_CHECK_RESPONSE',\r\n                payload: INTEGRITY_CHECKSUM,\r\n            })\r\n            break\r\n        }\r\n\r\n        case 'MOCK_ACTIVATE': {\r\n            activeClientIds.add(clientId)\r\n\r\n            sendToClient(client, {\r\n                type: 'MOCKING_ENABLED',\r\n                payload: true,\r\n            })\r\n            break\r\n        }\r\n\r\n        case 'MOCK_DEACTIVATE': {\r\n            activeClientIds.delete(clientId)\r\n            break\r\n        }\r\n\r\n        case 'CLIENT_CLOSED': {\r\n            activeClientIds.delete(clientId)\r\n\r\n            const remainingClients = allClients.filter((client) => {\r\n                return client.id !== clientId\r\n            })\r\n\r\n            // Unregister itself when there are no more clients\r\n            if (remainingClients.length === 0) {\r\n                self.registration.unregister()\r\n            }\r\n\r\n            break\r\n        }\r\n    }\r\n})\r\n\r\nself.addEventListener('fetch', function (event) {\r\n    const { request } = event\r\n    const accept = request.headers.get('accept') || ''\r\n\r\n    // Bypass server-sent events.\r\n    if (accept.includes('text/event-stream')) {\r\n        return\r\n    }\r\n\r\n    // Bypass navigation requests.\r\n    if (request.mode === 'navigate') {\r\n        return\r\n    }\r\n\r\n    // Opening the DevTools triggers the \"only-if-cached\" request\r\n    // that cannot be handled by the worker. Bypass such requests.\r\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\r\n        return\r\n    }\r\n\r\n    // Bypass all requests when there are no active clients.\r\n    // Prevents the self-unregistered worked from handling requests\r\n    // after it's been deleted (still remains active until the next reload).\r\n    if (activeClientIds.size === 0) {\r\n        return\r\n    }\r\n\r\n    // Generate unique request ID.\r\n    const requestId = Math.random().toString(16).slice(2)\r\n\r\n    event.respondWith(\r\n        handleRequest(event, requestId).catch((error) => {\r\n            if (error.name === 'NetworkError') {\r\n                console.warn(\r\n                    '[MSW] Successfully emulated a network error for the \"%s %s\" request.',\r\n                    request.method,\r\n                    request.url,\r\n                )\r\n                return\r\n            }\r\n\r\n            // At this point, any exception indicates an issue with the original request/response.\r\n            console.error(\r\n                `\\\r\n[MSW] Caught an exception from the \"%s %s\" request (%s). This is probably not a problem with Mock Service Worker. There is likely an additional logging output above.`,\r\n                request.method,\r\n                request.url,\r\n                `${error.name}: ${error.message}`,\r\n            )\r\n        }),\r\n    )\r\n})\r\n\r\nasync function handleRequest(event, requestId) {\r\n    const client = await resolveMainClient(event)\r\n    const response = await getResponse(event, client, requestId)\r\n\r\n    // Send back the response clone for the \"response:*\" life-cycle events.\r\n    // Ensure MSW is active and ready to handle the message, otherwise\r\n    // this message will pend indefinitely.\r\n    if (client && activeClientIds.has(client.id)) {\r\n        ; (async function () {\r\n            const clonedResponse = response.clone()\r\n            sendToClient(client, {\r\n                type: 'RESPONSE',\r\n                payload: {\r\n                    requestId,\r\n                    type: clonedResponse.type,\r\n                    ok: clonedResponse.ok,\r\n                    status: clonedResponse.status,\r\n                    statusText: clonedResponse.statusText,\r\n                    body:\r\n                        clonedResponse.body === null ? null : await clonedResponse.text(),\r\n                    headers: Object.fromEntries(clonedResponse.headers.entries()),\r\n                    redirected: clonedResponse.redirected,\r\n                },\r\n            })\r\n        })()\r\n    }\r\n\r\n    return response\r\n}\r\n\r\n// Resolve the main client for the given event.\r\n// Client that issues a request doesn't necessarily equal the client\r\n// that registered the worker. It's with the latter the worker should\r\n// communicate with during the response resolving phase.\r\nasync function resolveMainClient(event) {\r\n    const client = await self.clients.get(event.clientId)\r\n\r\n    if (client.frameType === 'top-level') {\r\n        return client\r\n    }\r\n\r\n    const allClients = await self.clients.matchAll({\r\n        type: 'window',\r\n    })\r\n\r\n    return allClients\r\n        .filter((client) => {\r\n            // Get only those clients that are currently visible.\r\n            return client.visibilityState === 'visible'\r\n        })\r\n        .find((client) => {\r\n            // Find the client ID that's recorded in the\r\n            // set of clients that have registered the worker.\r\n            return activeClientIds.has(client.id)\r\n        })\r\n}\r\n\r\nasync function getResponse(event, client, requestId) {\r\n    const { request } = event\r\n    const clonedRequest = request.clone()\r\n\r\n    function passthrough() {\r\n        // Clone the request because it might've been already used\r\n        // (i.e. its body has been read and sent to the cilent).\r\n        const headers = Object.fromEntries(clonedRequest.headers.entries())\r\n\r\n        // Remove MSW-specific request headers so the bypassed requests\r\n        // comply with the server's CORS preflight check.\r\n        // Operate with the headers as an object because request \"Headers\"\r\n        // are immutable.\r\n        delete headers['x-msw-bypass']\r\n\r\n        return fetch(clonedRequest, { headers })\r\n    }\r\n\r\n    // Bypass mocking when the client is not active.\r\n    if (!client) {\r\n        return passthrough()\r\n    }\r\n\r\n    // Bypass initial page load requests (i.e. static assets).\r\n    // The absence of the immediate/parent client in the map of the active clients\r\n    // means that MSW hasn't dispatched the \"MOCK_ACTIVATE\" event yet\r\n    // and is not ready to handle requests.\r\n    if (!activeClientIds.has(client.id)) {\r\n        return passthrough()\r\n    }\r\n\r\n    // Bypass requests with the explicit bypass header.\r\n    // Such requests can be issued by \"ctx.fetch()\".\r\n    if (request.headers.get('x-msw-bypass') === 'true') {\r\n        return passthrough()\r\n    }\r\n\r\n    // Notify the client that a request has been intercepted.\r\n    const clientMessage = await sendToClient(client, {\r\n        type: 'REQUEST',\r\n        payload: {\r\n            id: requestId,\r\n            url: request.url,\r\n            method: request.method,\r\n            headers: Object.fromEntries(request.headers.entries()),\r\n            cache: request.cache,\r\n            mode: request.mode,\r\n            credentials: request.credentials,\r\n            destination: request.destination,\r\n            integrity: request.integrity,\r\n            redirect: request.redirect,\r\n            referrer: request.referrer,\r\n            referrerPolicy: request.referrerPolicy,\r\n            body: await request.text(),\r\n            bodyUsed: request.bodyUsed,\r\n            keepalive: request.keepalive,\r\n        },\r\n    })\r\n\r\n    switch (clientMessage.type) {\r\n        case 'MOCK_RESPONSE': {\r\n            return respondWithMock(clientMessage.data)\r\n        }\r\n\r\n        case 'MOCK_NOT_FOUND': {\r\n            return passthrough()\r\n        }\r\n\r\n        case 'NETWORK_ERROR': {\r\n            const { name, message } = clientMessage.data\r\n            const networkError = new Error(message)\r\n            networkError.name = name\r\n\r\n            // Rejecting a \"respondWith\" promise emulates a network error.\r\n            throw networkError\r\n        }\r\n    }\r\n\r\n    return passthrough()\r\n}\r\n\r\nfunction sendToClient(client, message) {\r\n    return new Promise((resolve, reject) => {\r\n        const channel = new MessageChannel()\r\n\r\n        channel.port1.onmessage = (event) => {\r\n            if (event.data && event.data.error) {\r\n                return reject(event.data.error)\r\n            }\r\n\r\n            resolve(event.data)\r\n        }\r\n\r\n        client.postMessage(message, [channel.port2])\r\n    })\r\n}\r\n\r\nfunction sleep(timeMs) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, timeMs)\r\n    })\r\n}\r\n\r\nasync function respondWithMock(response) {\r\n    await sleep(response.delay)\r\n    return new Response(response.body, response)\r\n}\r\n"
    }
  ]
}
